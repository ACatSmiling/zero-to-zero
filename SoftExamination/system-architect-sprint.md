*date: 2024-03-13*

## 计算机硬件

### 中央处理单元 CPU

<img src="./system-architect-sprint/image-20240313230046456.png" alt="image-20240313230046456" style="zoom: 50%;" />

CPU 的功能：

- 程序控制
- 操作控制
- 时间控制
- 数据处理

CPU 的组成：

- `运算器`（**数据加工、算术运算、逻辑运算**）
  - 算术逻辑单元 ALU
  - 累加器
  - 状态条件寄存器
  - 缓冲寄存器
- `控制器`（**保证指令执行、处理异常事件**）
  - 指令寄存器
  - 程序计数器
  - 地址寄存器
  - 指令译码器
- `寄存器组`（**保存程序的中间结果**）
- `总线`

>在 CPU 中，（ ）不仅要保证指令的正确执行，还要能够处理异常事件。
>
>A. 运算器
>
>B. 控制器
>
>C. 寄存器
>
>D. 内部总线
>
>【答案】B

### 数据表示

#### 二进制转十进制

`无符号的二进制整数`：**从右往左依次用二进制位上的位数乘以 2 的 n 次幂的和（n 大于等于 0）**。

`带符号的二进制整数`：除去**最高位的符号位（1 为负数，0 为正数）**，其余与无符号二进制转化为十进制方法相同。

`小数二进制数`：从小数点后第 1 位上的二进制数字乘以 2 的负一次方，加上第 2 位上的二进制数字乘以 2 的负二次方，以此类推**第 n 位上的二进制数字乘以 2 的负 n 次方**。

>将二进制 1100.101 转化为十进制，结果是（ ）。
>
>A. 12.625
>
>B. 12.75
>
>C. 24.625
>
>D. 24.75
>
>【答案】A

#### 十进制转二进制

`转化整数`：

1. 将**整数部分除 2，取余**。
2. 当商不为 0 时，将商作为被除数。
3. 继续除 2 取余，直至商为 0。
4. 将**余数按从下到上的顺序记录**。

`转化小数`：

1. 将**小数部分乘 2，取整**。
2. 如果结果仍有小数，就继续乘 2。
3. 直到小数部分为 0，或者已经达到了精度要求。
4. 将**取整的结果按从上到下的顺序记录**。

>将十进制 11.75 转化为二进制，结果是（ ）。
>
>A. 1011.11
>
>B. 1010.11
>
>C. 1010.01
>
>D. 1011.01
>
>【答案】A

#### 原码

**最高位是符号位，0 表示正号，1 表示负号，其余的 n-1 位表示数值的绝对值。**

- 数值 0 的原码表示有两种形式：[+0]~原~ = 0 0000000，[-0]~原~ = 1 0000000。

以带符号位的四位二进制数为例：1010，最高位为 1 表示这是一个负数，其它三位 010，即 $0*2^2+1*2^1+0*2^0=2$，所以 1010 表示十进制数 -2。

>若机器字长为 8，则 +127 和 -0.5 分为表示为（ ）。
>
>A. 0 1111111，0 1000101
>
>B. 0 1111111，1 1000000
>
>C. 1 1111111，0 1000000
>
>D. 1 0000000，1 1000101
>
>【答案】B

#### 反码

**原码最大的问题就在于一个数加上它的相反数不等于 0。**例如：1~原~ = 0001，-1~原~ = 1001，则 1~原~ + (-1~原~) = 1010，即得出 1 + (-1) = -2，这很明显是错误的。

`正数的反码`：等于它的原码。

`负数的反码`：将负数绝对值的原码，除符号位外，其它位按位取反。

- 数值 0 的反码表示有两种形式：[+0]~反~ = 0 0000000，[-0]~反~= 1 1111111。

#### 补码

**反码也无法解决负数相加的问题。**例如：-1~反~ = 1110，-3~反~ = 1100，则 (-1~反~) + (-3~反~) = 1010，1010 的原码为 1101，即 -5，这很明显也是错误的。

`正数的补码`：等于它的原码。

`负数的补码`：等于它的反码 +1 或等于 $(2^{机器字长}-|负数|)$所得结果的原码。

- 数值 0 有唯一的编码：[+0]~补~ = 0 0000000，[-0]~补~ = 0 0000000。

**`计算机中均采用补码进行加减运算。`**

例如：若机器字长为 4，计算 6 - 2 。

解答：6~原~ = 0110 ---> 6~反~ = 0110 ---> 6~补~ = 0110，-2~原~ = 1010 ---> -2~反~ = 1101 ---> -2~补~ = 1110，则 6~补~ + (-2~补~) = 0100，即结果是一个正数，正数的补码等于反码等于源码，也就是 6 - 2 = 4，结果正确。

>如果 2X 的补码是 90H，那么 X 的真值是（ ）。（2016 上半年试题)
>
>A. 56
>
>B. -56
>
>C. 72
>
>D. -72
>
>【答案】B
>
>【解析】**十六进制用符号 H 或者 0x 表示，每一位十六进制代表四位二进制。**十六进制数 90，转换为二进制数为 1001 0000，补码 1001 0000 对应的反码为 1000 1111，再对应原码为 1111 0000，即 -112，因为 2X = -112，所以 X = -56。
>
>
>
>计算机系统中采用补码表示有符号的数值，（ ）。（2022 下半年试题）
>
>A. 可以保持加法和减法运算过程与手工运算方式一致
>
>B. 可以提高运算过程和结果的精准程度
>
>C. 可以提高加法和减法运算的速度
>
>D. 可以将减法运算转换为加法运算从而简化运算器的设计
>
>【答案】D
>
>
>
>原码表示法和补码表示法是计算机中用于表示数据的两种编码方法，在计算机系统中常采用补码来表示和运算数据，原因是采用补码可以（ ）。（2011 上半年试题）
>
>A. 保证运算过程与手工运算方法保持一致
>
>B. 简化计算机运算部件的设计
>
>C. 提高数据的运算速度
>
>D. 提高数据的运算精度
>
>【答案】B

#### 移码

`移码`：补码的符号位取反，移码的主要用途是表示浮点数的指数（阶码）。

|        | 正数                                                         | 负数                                                         |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `原码` | **最高位为符号位 0 表示正号，其他位存放该数的二进制的绝对值** | **最高位为符号位 1 表示负号，其他位存放该数的二进制的绝对值** |
| `反码` | **等于原码**                                                 | **按它的原码，除符号位外，按位取反**                         |
| `补码` | **等于原码**                                                 | **反码 +1 或等于 $(2^{机器字长}-|负数|)$~原~**               |
| `移码` | **补码的符号位取反**                                         | **补码的符号位取反**                                         |

#### 浮点数

浮点数的表示形式：**N = 尾数 × 基数^阶码（指数）^**

- 二进制中，基数都是 2，十进制中，基数都是 10，其他进制类推。
- 尾数一般是一个小数，阶码一般是一个整数。例如：1.23 × 10^5^。

浮点数的表示格式：

| 数符             | 阶符             |
| ---------------- | ---------------- |
| 尾数（**补码**） | 阶码（**移码**） |

- `尾数`：**用补码表示，位数决定数的有效精度，位数越多精度越高。**
- `阶码`：**用移码表示，位数决定数的表示范围，位数越多范围越大。**
- 对阶时，小数向大数看齐。
- 对阶是通过较小数的尾数右移实现的。

>浮点数的表示分为阶和尾数两部分。两个浮点数相加时，需要先对阶，即（ ）（n 为阶差的绝对值）。（2018 上半年试题）
>
>A. 将大阶向小阶对齐，同时将尾数左移 n 位
>
>B. 将大阶向小阶对齐，同时将尾数右移 n 位
>
>C. 将小阶向大阶对齐，同时将尾数左移 n 位
>
>D. 将小阶向大阶对齐，同时将尾数右移 n 位
>
>【答案】D
>
>
>
>对于长度相同但格式不同的两种浮点数，假设前者阶码长、尾数短，后者阶码短、尾数长，其它规定都相同，则二者可以表示数值的范围和精度情况为（ ）。（2022 下半年试题）
>
>A. 二者可表示的数的范围和精度相同
>
>B. 前者所表示的数的范围更大且精度更高
>
>C. 前者所表示的数的范围更大但精度更低
>
>D. 前者所表示的数的范围更小但精度更高
>
>【答案】C

### 校验码

#### 奇偶校验

`奇偶校验码`的编码方法是：由若干位有效信息的头部或者尾部，再加上一个二进制位（校验位）组成校验码。

- `奇校验`：整个校验码（有效信息位和校验位）中 "1" 的个数为奇数。
- `偶校验`：整个校验码（有效信息位和校验位）中 "1" 的个数为偶数。

**奇偶校验码只能纠错，不能纠错：**

- 如果有**奇数个位发生误码**，则奇偶性发生变化，**可以检查出误码，但不能纠错。**
- 如果有**偶数个位发生误码**，则奇偶性不发生变化，**不能检查出误码（也称漏检）。**

>给出编码 1001101 的奇校验码和偶校验码（ ）。
>
>A. 10011011，10011010
>
>B. 10011011，10011011
>
>C. 10011010，10011010
>
>D. 10011010，10011010
>
>【答案】A

#### 模 2 除法

模 2 除法计算过程：

1. 被除数首位是几商就上几；
2. 异或运算；
3. 异或后首位一定是0，舍弃掉这个0首位；
4. 补末位（落数），再上商。

例如，1011 0010 000 模2 除 1100 1，过程如下：

<img src="./system-architect-sprint/image-20240316143512427.png" alt="image-20240316143512427" style="zoom:50%;" />

计算到最后，余数为 4 位数，小于被除数 5 位数，计算完成。

#### 循环冗余校验 CRC

流程：

- 收发双方约定好一个生成多项式 G(x)；

- 发送方基于待发送的数据和生成多项式计算出差错检测码（冗余码），然后将其添加到待传输数据的后面一起传输；

- 接收方通过生成多项式来计算收到的数据是否产生了误码。

  ● 算法要求生成多项式必须包含最低次项

示例一，待发送的信息为 1010 01，生成多项式为 G(x) = x^3^ + x^2^ + 1，计算编码后的信息。

1. **构造被除数：在待发送信息后面，添加生成多项式最高次数个 0。**即：1010 0100 0。

2. **构造除数：生成多项式各项系数构成的比特串。**即：1101。

3. **做模二除法运算。**得到余数为 1。

   <img src="./system-architect-sprint/image-20240316162956463.png" alt="image-20240316162956463" style="zoom:50%;" />

4. **检查余数：余数的位数应与生成多项式最高次数相同，如果位数不够，则在余数前补 0 来凑足位数。**即：001。

5. 因此，编码后的信息为：${\color{red}1010 01}$${\color{green}00 1}$。

示例二，接收到的信息为 1011 0100 1，生成多项式为 G(x) = x^3^ + x^2^ + 1，判断传输是否有误码。

1. **构造被除数：接收到的信息就是被除数。**即：1011 0100 1。

2. **构造除数：生成多项式各项系数构成的比特串。**即：1101。

3. **做模二除法运算。**得到余数为 11。

   <img src="./system-architect-sprint/image-20240316164514276.png" alt="image-20240316164514276" style="zoom:50%;" />

4. **检查余数：余数为 0，传输过程无误码；余数不为 0，传输过程产生误码。**

5. 因此，传输过程产生了误码。

>在（ ）校验方法中，采用模 2 运算来构造校验位。（2019 上半年试题）
>
>A. 水平奇偶
>
>B. 垂直奇偶
>
>C. 海明码
>
>D. 循环冗余
>
>【答案】D

#### 海明校验

**设数据位是 n 位，校验位是 k 位，则 n 和 k 必须满足以下关系：2^k^ － 1 >= n + k。**

海明码的编码规则如下：设 k 个校验位为 P~k~，P~k-1~，…，P~1~，n 个数据位为 D~n~，D~n-1~，…，D~1~，对应的海明码为 H~n+k~，H~n+k-1~，…，H~1~。

（1）校验码 P~i~ 要放在 2^i-1^ 的位置。

（2）海明码中的任何一位都是由若干个校验位来校验的。

（3）被校验的海明位的下标，**等于所有参与校验该位的校验位的下标之和**，而校验位由自身校验。

>待传送的信息为 1010，若采用海明校验，则奇校验规则下的海明码是（ ）。
>
>A. 0110 010
>
>B. 0110 011
>
>C. 1110 010
>
>D. 1110 011
>
>【答案】A
>
>【解析】
>
>1. 数据位 n 等于 4，根据校验位和数据位之间的关系，校验位 k 等于 3（2^k^ >= 5 + k），海明位一共为 4 + 3 = 7。
>
>2. 因为校验码放在 2^i-1^ 的位置，则数据位和校验位之间的位置关系为：P1，P2，D1，P3，D2，D3，D4。海明位与数据位和校验位的关系为：
>
>   <img src="./system-architect-sprint/image-20240316171625487.png" alt="image-20240316171625487" style="zoom:50%;" />
>
>3. 海明位下标与校验位下标关系表（注意，校验位的下标是该校验位在海明位对应的位置，满足 2^i^ 条件，i 是大于等于 0 的整数）：
>
>   <img src="./system-architect-sprint/image-20240316194130312.png" alt="image-20240316194130312" style="zoom:50%;" />
>
>4. 根据上表，得出校验位和数据位的对应关系，进而根据对应的数据位数据，求出奇/偶校验码规则下对应的海明码：
>
>   <img src="./system-architect-sprint/image-20240316194715914.png" alt="image-20240316194715914" style="zoom:50%;" />
>
>5. 根据计算出来的奇/偶校验码规则下对应的海明码，将海明码填到对应的位置：
>
>   <img src="./system-architect-sprint/image-20240316195033389.png" alt="image-20240316195033389" style="zoom:50%;" />
>
>6. 因此，奇校验规则下，传输的信息为 0110 010。如果是偶校验规则，传输的信息为 1011 010。

### 存储器

#### 存储器的层次结构

<img src="./system-architect-sprint/image-20240316223537530.png" alt="image-20240316223537530" style="zoom: 33%;" />

>在程序的执行过程中，Cache 与主存的地址映射是由（ ）完成的。（2017 下半年试题）
>
>A. 操作系统
>
>B. 程序员调度
>
>C. 硬件自动
>
>D. 用户软件
>
>【答案】C

#### 高速缓存 Cache

特点：

- Cache 位于 CPU 与主存之间。

- Cache 对程序员来说是透明的。

- 设置多级高速缓存 Cache 以提高命中率（访问主存的效率）。

- **使用 Cache 改善系统性能的依据是程序的局部性原理。**

  <img src="./system-architect-sprint/image-20240316224600952.png" alt="image-20240316224600952" style="zoom: 50%;" />

  - `时间局部性`：被引用过一次的存储器位置在未来会被多次引用，**主要体现是循环**。
  - `空间局部性`：如果一个存储器的位置被引用，那么将来它附近的位置也会被引用，**主要体现是顺序执行的过程**。

>在 CPU 内外常设置多级高速缓存 Cache 其主要目的是（ ）。（2019 下半年试题）
>
>A. 扩大主存的存储容量
>
>B. 提高 CPU 访问主存数据或指令的效率
>
>C. 扩大存储系统的容量
>
>D. 提高 CPU 访问外存储器的速度
>
>【答案】B

#### Cache 的地址映像方法

<img src="./system-architect-sprint/image-20240316224752879.png" alt="image-20240316224752879" style="zoom:67%;" />

>Cache 的地址映像方式中，发生块冲突次数最小的是（ ）。（2015 年上半年）
>
>A. 全相联映像
>
>B. 组相联映像
>
>C. 直接映像
>
>D. 无法确定
>
>【答案】A

#### Cache 替换算法

<img src="./system-architect-sprint/image-20240316225305221.png" alt="image-20240316225305221" style="zoom:67%;" />

>Cache 的替换算法中，（ ）算法计数器位数多，实现困难。
>
>A. FIFO
>
>B. LFU
>
>C. LRU
>
>D. RAND
>
>【答案】B

#### 磁盘（外存储器）

<img src="./system-architect-sprint/image-20240316225631889.png" alt="image-20240316225631889" style="zoom:67%;" />

机械磁盘存在两组运动：

- 磁盘的**旋转运动**。
- 机械臂控制磁头**沿半经方向的直线运动**。

**存取时间 = 寻道时间 + 等待时间：**

- `寻道时间`：指磁头移动到磁道所需的时间。
- `等待时间`：等待读写的扇区转到磁头下方所用的时间。
- 相较于寻道时间和等待时间，数据写入磁盘的时间微不足道，因此存取时间只考虑寻道时间和等待时间。

>在磁盘调度管理中，通常（ ）。（2019 下半年试题）
>
>A. 先进行旋转调度，再进行移臂调度
>
>B. 在访问不同柱面的信息时，只需要进行旋转调度
>
>C. 先进行移臂调度，再进行旋转调度
>
>D. 在访问同一磁道的信息时，只需要进行移臂调度
>
>【答案】C

### 输入/输出技术

输入/输出技术，是指 CPU 控制主存与外设之间数据交互的过程。因为外设处理速度比主存慢很多，对于二者之间的平衡，常见的方式有：

- `直接程序控制`
  - 分为无条件传送和程序查询方式。
  - 降低了 CPU 的效率。
  - 对外部的突发事件无法做出实时响应。
- `程序中断方式`
  - 利用中断方式完成数据的输入/输出。
  - CPU 接到中断请求信号后，保存正在执行程序的现场。
  - 与程序控制方式相比，因为 CPU 无须等待而提高了效率。
- `DMA`
  - 在主存与 I/O 设备（外设）之间建立数据通路，进行数据的交换处理。
  - 在 DMA 传送过程中无须 CPU 的干预。
  - DMA 传送数据时要占用系统总线，此时，CPU 不能使用总线。
- `输入/输出处理机 (IOP)`
  - 分担了 CPU 的一部分功能，可以实现对外围设备的统一管理，完成外围设备与主存之间的数据传送。
  - 大大提高了 CPU 的工作效率，这种效率的提高是以增加更多的硬件为代价的。

>DMA 控制方式是在（ ）之间直接建立数据通路进行数据的交换处理。（2019 年上半年试题软设）
>
>A. CPU 与主存
>
>B. CPU 与外设
>
>C. 主存与外设
>
>D. 外设与外设
>
>【答案】C
>
>
>
>计算机运行过程中，CPU 需要与外设进行数据交换。采用（ ）控制技术时，CPU 与外设可并行工作。（2017 年下半年)
>
>A. 程序查询方式和中断方式
>
>B. 中断方式和 DMA 方式
>
>C. 程序查询方式和 DMA 方式
>
>D. 程序查询方式、中断方式和 DMA 方式
>
>【答案】B

### Flynn 分类法

**根据指令流和数据流的不同组合**，将计算机分为四种类型：

<img src="./system-architect-sprint/image-20240319223424058.png" alt="image-20240319223424058" style="zoom:67%;" />

<img src="./system-architect-sprint/image-20240319223458053.png" alt="image-20240319223458053" style="zoom:67%;" />

>Flynn 分类法根据计算机在执行程序的过程中（ ）的不同组合，将计算机分为 4 类，当前主流的多核计算机属于（ ）计算机。
>
>A. 指令流和数据流
>
>B. 数据流和控制流
>
>C. 指令流和控制流
>
>D. 数据流和总线带宽
>
>A. SISD
>
>B. SIMD
>
>C. MISD
>
>D. MIMD
>
>【答案】A D

### 指令系统

| 指令系统类型 | 指令                                                         | 寻址方式   | 实现方式                                               | 其他                       | 代表        |
| ------------ | ------------------------------------------------------------ | ---------- | ------------------------------------------------------ | -------------------------- | ----------- |
| CISC（复杂） | 数量多，使用频率差别大，可变长格式                           | 支持多种   | 微程序控制技术（微码）                                 | 研制周期长                 | X86         |
| RISC（精简） | 数量少，使用频率接近，定长格式，大部分为单周期指令，操作寄存器，只有 Load/Store 操作内存 | 支持方式少 | 增加了通用寄存器，硬布线逻辑控制为主，更适合采用流水线 | 优化编译，有效支持高级语言 | RISC-V，ARM |

>以下关于 RISC 和 CISC 的叙述中，不正确的是（ ）。（2022 年上半年）
>
>A. RISC 的大多指令在一个时钟周期内完成
>
>B. RISC 普遍采用微程序控制器，CISC 则普遍采用硬布线控制器
>
>C. RISC 的指令种类和寻址方式相对于 CISC 更少
>
>D. RISC 和 CISC 都采用流水线技术
>
>【答案】B
>
>【解析】CISC 普遍采用微程序控制器，RISC 则普遍采用硬布线控制器

### 流水线

`流水线`是指**在程序执行时多条指令重叠进行操作的一种准并行处理实现技术**。各种部件同时处理是针对不同指令而言的，它们可同时为多条指令的不同部分进行工作，以提高各部件的利用率和指令的平均执行速度。

<img src="./system-architect-sprint/image-20240319230839504.png" alt="image-20240319230839504" style="zoom:67%;" />

<img src="./system-architect-sprint/image-20240319230911874.png" alt="image-20240319230911874" style="zoom: 80%;" />

一条指令的执行过程可以分解为取指、分析和执行三步，在取指时间 t~取指~ = 3△t、分析时间 t~分析~ = 2△t、执行时间 t~执行~ = 4△t 的情况下，若按串行方式执行，则 10 条指令全部执行完需要（ ）△t；若按流水线的方式执行，流水线周期为（ ）△t，则 10 条指令全部执行完需要（ ）△t。

- (3△t + 2△t + 4△t) * 10 = 90△t
- 流水线周期 = 时间最长的指令 = 4△t
- 流水线执行时，若按照理论公式为：(3△t + 2△t + 4△t) + (10 - 1) * 4△t = 45△t，若按照实践公式为：3 * 4△t + (10 - 1) * 4△t = 48△t。（优先计算理论公式的值）

流水线的`吞吐率`（Though Put rate，TP）是指**在单位时间内流水线所完成的任务数量或输出的结果数量**。计算流水线吞吐率的最基本公式如下：

<img src="./system-architect-sprint/image-20240319231659522.png" alt="image-20240319231659522" style="zoom:67%;" />

流水线的`最大吞吐率`（n 是指令的条数）：

<img src="./system-architect-sprint/image-20240319231747541.png" alt="image-20240319231747541" style="zoom:67%;" />

流水线的`加速比`是指完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比。计算流水线的加速比的公式如下：

<img src="./system-architect-sprint/image-20240319231930019.png" alt="image-20240319231930019" style="zoom:67%;" />

>执行指令时，将每一节指令都分解为取指、分析和执行三步。已知取指时间 5△t，分析时间 2△t，执行时间 3△t，如果按照取指、分析、执行重叠的流水线方式执行指令，从头到尾执行完 500 条指令需（ ）△t。（2019 年下半年）
>
>A. 2500 
>
>B. 2505 
>
>C. 2510 
>
>D. 2515
>
>【答案】B
>
>【解析】理论公式：(5△t + 2△t + 3△t) + (500 - 1) * 5△t = 2505△t，实践公式：3 * 5△t + (500 -1) * 5△t = 2510△t，优先选择理论公式计算的结果。

### 冯诺依曼结构和哈弗结构

<img src="./system-architect-sprint/image-20240319232258533.png" alt="image-20240319232258533" style="zoom:67%;" />

>目前处理器市场中存在 CPU、GPU 和 DSP 多种类型处理器，分别用于不同场景，这些处理器具有不同的体系结构，DSP 采用（ ）。
>
>A. 冯·诺依曼结构 
>
>B. 哈佛结构 
>
>C. FPGA 结构 
>
>D. 与 GPU 相同结构
>
>【答案】B
>
>【解析】FPGA 是指可编程门阵列，是一种电路结构，不是处理器的体系结构划分。GPU，图形处理器，即显卡，没有所谓的体系结构划分。
>
>
>
>以下关于冯·诺依曼计算机的叙述中，不正确的是（ ）。（2022 年上半年)
>
>A. 程序指令和数据都采用二进制表示
>
>B. 程序指令总是存储在主存中，而数据则存储在高速缓存中
>
>C. 程序的功能都由中央处理器（CPU）执行指令来实现
>
>D. 程序的执行工作由指令进行自动控制
>
>【答案】B
>
>【解析】冯·诺依曼结构中，程序指令和数据存储在同一个存储器中。

### 总线

特点：

- `共享`：总线的部件相互之间可以进行信息的交换。
- `分时`：同一时刻仅允许一个部件向总线发送信息，但允许多个部件同时从总线上接收相同的信息。

通信方向：

- `单工`:一个方向上传输（正向或反向），不能改变信号的传输方向。
- `半双工`：一种可切换方向的单工通信。
- `全双工`：双向的传输。

分类：

- `串行总线`：适合长距离传输。
- `并行总线`：适合近距离传输。

功能分类：

- `数据总线`：Data Bus，DB，在 CPU 与 RAM（Random Access Memory）之间来回传送需要处理或是需要储存的数据。
- `地址总线`：Address Bus，AB，用来指定在 RAM 之中储存的数据的地址。
- `控制总线`：Control Bus，CB，将微处理器控制单元（Control Unit）的信号，传送到周边设备。

>以下关于总线的叙述中，不正确的是（ ）。
>
>A. 并行总线适合近距离高速数据传输
>
>B. 串行总线适合长距离数据传输
>
>C. 单总线结构在一个总线上适应不同种类的设备，设计简单且性能很高
>
>D. 专用总线在设计上可以与连接设备实现最佳匹配
>
>【答案】C
>
>【解析】单总线性能不高。

### 加密和认证

#### 对称加密技术

`对称加密`是指信息的发送方和接收方使用同一个密钥去加密和解密数据。

- 加密过程：明文 + 加密算法 + 私钥 => 密文。
- 解密过程：密文 + 解密算法 + 私钥 => 明文。

特点：算法公开、加密和解密速度快，适合于对大数据量进行加密。加密强度不够、密钥安全管理困难。

常见的对称加密算法：**DES、3DES、RC、IDEA、PGP、AES 等。**

#### 非对称加密技术

`非对称加密`与对称加密相比，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对密钥，即**公钥和私钥**，且二者成对出现。私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。用公钥或私钥中的任何一个进行加密，用另一个进行解密。

<img src="./system-architect-sprint/image-20240320221422293.png" alt="image-20240320221422293" style="zoom:67%;" />

特点：非对称加密算法的保密性比较好，它消除了最终用户交换密钥的需要，但加密和解密花费的时间长、速度慢，不适合于对文件加密，而只适用于对少量数据进行加密。

常见的非对称加密算法：**RSA、DSA、ECC（椭园曲线算法）等。**

#### 信息摘要

`信息摘要`简要地描述了一份较长的信息或文件，它可以被看作一份长文件的 "数字指纹"，**信息摘要用于创建数字签名**，对于特定的文件而言，信息摘要是唯一的。

- 信息摘要可以被公开，它不会透露相应文件的任何内容。

- 原始数据不同，生成的摘要一定不同，单向不可逆。

信息摘要算法：

<img src="./system-architect-sprint/image-20240320221623801.png" alt="image-20240320221623801" style="zoom:67%;" />

#### 数字签名

`数字签名`采用非对称密码体制（公钥密码体制），即发送者使用私钥加密数据，接收者使用对应的公钥解密数据，它具有以下功能：

- 报文鉴别：用于证明来源，接收者可以通过签名确定是哪个发送者进行的签名。

- 防止抵赖：防止发送者否认签名，发送者一旦签名，标记就打上了，无法抵赖。
- 防止伪造：防止接收者伪造发送者的签名。

>下列算法中属于非对称加密算法的是（ ）。（2021 年上半年)
>
>A. DES
>
>B. RSA
>
>C. AES
>
>D. MD5
>
>【答案】B

### 计算机可靠性模型

`串联系统`：假设一个系统由 N 个子系统组成，当且仅当所有的子系统都能正常工作时系统才能正常工作，这种系统称为串联系统。

<img src="./system-architect-sprint/image-20240320222019579.png" alt="image-20240320222019579" style="zoom:67%;" />

- 设系统中各个子系统的可靠性分别用 R~1~，R~2~，......，R~N~ 来表示，则系统的可靠性 R 可由下式求得：R = R~1~ R~2~ ... R~N~。

`并联系统`：假如一个系统由 N 个子系统组成，只要有一个子系统正常工作，系统就能正常工作，这样的系统称为并联系统。

<img src="./system-architect-sprint/image-20240320222106578.png" alt="image-20240320222106578" style="zoom:67%;" />

- 设每个子系统的可靠性分别以 R~1~，R~2~，......，R~N~ 表示，则整个系统的可靠性 R 可由下式求得：R = 1- (1- R~1~) (1- R~2~) ... (1- R~N~)。

>某系统由 3 个部件构成，每个部件的千小时可靠度都为 R，该系统的千小时可靠度为 (1 - (1 - R)^2^) R，则该系统的构成方式是（ ）。（2019 年下半年）
>
>A. 3 个部件串联
>
>B. 3 个部件并联
>
>C. 前两个部件并联后与第三个部件串联
>
>D. 第一个部件与后两个部件并联构成的子系统串联
>
>【答案】C
>
>【解析】选项 D 的可靠度为：R (1 - (1 - R)^2^)

## 操作系统

### 概述

操作系统的作用：通过资源管理提高计算机系统的效率；改善人机界面向用户提供友好的工作环境。

操作系统的特征：`并发性`、`共享性`、`虚拟性`、`不确定性`。

操作系统的功能：`进程管理`、`存储管理`、`文件管理`、`设备管理`、作业管理。

操作系统的分类：批处理操作系统、分时操作系统（轮流使用 CPU 工作片）、实时操作系统（快速响应）、网络操作系统、分布式操作系统（物理分散的计算机互联系统）、微机操作系统（Windows）、嵌入式操作系统。

计算机启动的基本流程为：BIOS ---> 主引导记录 ---> 操作系统。

#### 微内核操作系统

`微内核`，顾名思义，就是尽可能的将内核做的很小，**只将最为核心必要的东西放入内核中**，其他能独立的东西都放入用户进程中，这样，**系统就被分为了用户态和内核态**。

<img src="./system-architect-sprint/image-20240323185200205.png" alt="image-20240323185200205" style="zoom:67%;" />

单体内核 VS 微内核：

|          | 实质                                                         | 优点                                                         | 缺点                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 单体内核 | 将图形、设备驱动及文件系统等功能，全部在内核中实现，运行在内核状态和同一地址空间 | 减少进程间通信和状态切换的系统开销，获得较高的运行效率       | 内核庞大，占用资源较多且不易裁剪。系统的稳定性和安全性不好   |
| 微内核   | 只实现基本功能，将图形系统、文件系统、设备驱动及通信功能放在内核之外 | 内核精炼，便于裁剪和移植。系统服务程序运行在用户地址空间，系统的可靠性、稳定性和安全性较高。可用于分布式系统 | 用户状态和内核状态需要频繁切换，从而导致系统效率不如单体内核 |

#### 嵌入式操作系统

`嵌入式操作系统`特点：**微型化、代码质量高、专业化、实时性强、可裁剪可配置。**

实时嵌入式操作系统的内核服务：异常和中断、计时器、I/O 管理。

常见的嵌入式 RTOS（实时操作系统）：VxWorks、RT-Linux、QNX、pSOS。

嵌入式系统初始化过程按照自底向上、从硬件到软件的次序依次为：芯片级初始化 ---> 板卡级初始化 ---> 系统级初始化。**芯片级是微处理器的初始化，板卡级是其他硬件设备初始化，系统级初始化就是软件及操作系统初始化。**

### 进程管理

#### 进程的组成和状态

`进程`是**计算机中正在运行的程序的实例，它是操作系统进行资源分配和管理的基本单位，包括代码、数据和执行状态等信息。**

进程的组成：`进程控制块 PCB (唯一标志)`、`程序 (描述进程要做什么)`、`数据 (存放进程执行时所需的数据)`。

进程基础的状态时下左图中的三态图，这是系统自动控制时只有三种状态，而下右图中的五态，是多了两种状态：静止就绪和静止阻塞，需要人为的操作才会进入对应状态，活跃就绪即就绪，活跃阻塞即等待。

<img src="./system-architect-sprint/image-20240320232543255.png" alt="image-20240320232543255" style="zoom:67%;" />

#### 前趋图

`前趋图`：用来表示哪些任务可以并行执行，哪些任务之间有顺序关系。具体如下图：

<img src="./system-architect-sprint/image-20240320232738630.png" alt="image-20240320232738630" style="zoom: 50%;" />

- 可知，ABC 可以并行执行，但是必须 ABC 都执行完后，才能执行 D，这就确定了两点：`任务间的并行`、`任务间的先后顺序`。

#### 进程资源图

`进程资源图`：用来表示进程和资源之间的分配和请求关系。如下图所示：

<img src="./system-architect-sprint/image-20240320232850366.png" alt="image-20240320232850366" style="zoom: 50%;" />

- **P 代表进程，R 代表资源，R 方框中有几个圆球就表示有几个这种资源。**在图中，R1 指向 P1，表示 R1 有一个资源已经分配给了 P1，P1 指向 R2，表示 P1 还需要请求一个 R2 资源才能执行。

`阻塞节点`：某进程所请求的资源已经全部分配完毕，无法获取所需资源，该进程被阻塞了无法继续。如上图中 P2。

`非阻塞节点`：某进程所请求的资源还有剩余，可以分配给该进程继续运行。如上图中 P1、P3。当一个进程资源图中所有进程都是阻塞节点时，即陷入死锁状态。

>在如下所示的进程资源图中，（）；该进程资源图是（）。
>
><img src="./system-architect-sprint/image-20240320233214615.png" alt="image-20240320233214615" style="zoom:50%;" />
>
>A. P1、P2、P3 都是阻塞节点
>
>B. P1 是阻塞节点，P2、P3 是非阻塞节点
>
>C. P1、P2 是阻塞节点，P3 是非阻塞节点
>
>D. P1、P2 是非阻塞节点，P3 是阻塞节点
>
>A. 可以化简的，其化简顺序为 P1 ---> P2 ---> P3
>
>B. 可以化简的，其化简顺序为 P3 ---> P1 ---> P2
>
>C. 可以化简的，其化简顺序为 P2 ---> P1 ---> P3
>
>D. 不可以化简的，因为 P1、P2、P3 申请的资源都不能得
>
>【答案】C B

#### 同步与互斥

`互斥`：指多个进程只能互斥地访问某个资源（即临界资源），即只有一个进程可以访问该资源，其他进程必须等待。互斥可以防止多个进程同时访问同一个资源，从而避免数据损坏和程序崩溃。如打印机、公共厕所。

`临界资源`：各进程间需要以互斥方式对其进行访问的资源。

`互斥信号量`：对临界资源采用互斥访问，实现进程的互斥，使用互斥信号量后其他进程无法访问，**其值只能为 0 或 1**。比如厕所的门锁有两个状态：打开和关闭。当门锁打开时，表示厕所空闲，可以进入。当门锁关闭时，表示厕所有人使用，其他人需要等待。门锁就像是互斥信号量，它表示厕所的使用状态。人就像是进程，他们需要获取门锁才能使用厕所。

`同步`：指多个进程之间互相协调，以确保它们按照一定的顺序执行。同步可以防止进程之间出现竞争和冲突，从而提高程序的正确性和效率。比如多个人一起做某件事情。

`同步信号量`：是一种用于实现进程同步的工具。**它是一个共享变量，可以用来表示资源的数量。**比如餐厅里的餐桌数量有限，当顾客来吃饭时，如果餐桌空闲，则可以直接坐下。如果餐桌都满了，则顾客需要等待，餐桌就像是同步信号量，它表示餐桌的数量。顾客就像是进程，他们需要获取餐桌才能吃饭。

#### 信号量

`P 操作`：申请资源，S = S - 1，若S >= 0，则执行 P 操作的进程继续执行；若 S < 0，则置该进程为阻塞状态（因为无可用资源），并将其插入阻塞队列。

- S 减去 1 之后，若小于 0，说明申请资源时，没有可用资源存在，申请资源的线程进入阻塞队列。

`V 操作`：释放资源，S = S + 1，若 S > 0，代表此时资源有空余，没有阻塞的进程，则该进程继续执行；若 S <= 0，代表此时线程在被阻塞，所以需要从阻塞状态唤醒一个进程，并将其插入就绪队列（此时因为缺少资源被 P 操作阻塞的进程可以继续执行），然后执行 V 操作的进程继续。

- S 加上 1 之后，若 S <= 0，说明释放资源后，有正在阻塞的线程等待资源，因此需要从阻塞状态唤醒一个进程，该进程进入就绪队列。

<img src="./system-architect-sprint/image-20240321221300668.png" alt="image-20240321221300668" style="zoom:67%;" />

>进程 P1、P2、P3、P4 和 P5 的前趋图如下图所示：
>
><img src="./system-architect-sprint/image-20240323215831936.png" alt="image-20240323215831936" style="zoom:50%;" />
>
>若用 PV 操作控制进程 P1、P2、P3、P4 和 P5 并发执行的过程，则需要设置 5 个信号 S1、S2、S3、S4 和 S5，且信号量 S1～S5 的初值都等于零。下图中 a 和 b 处应分别填（）；c 和 d 处应分别填写（）；e 和 f 处应分别填写（）。
>
><img src="./system-architect-sprint/image-20240323215917790.png" alt="image-20240323215917790" style="zoom:50%;" />
>
>A. V(S1) P(S2) 和 V(S3)						B. P(S1) V(S2) 和 V(S3)						C. V(S1) V(S2) 和 V(S3)						D. P(S1) P(S2) 和 V(S3)
>
>A. P(S2) 和 P(S4)								B. P(S2) 和 V(S4)								C. V(S2) 和 P(S4)								D. V(S2) 和 V(S4)
>
>A. P(S4) 和 V(S4) V(S5)							B. V(S5) 和 P(S4) P(S5)							C. V(S3) 和 V(S4) V(S5)							D. P(S3) 和 P(S4) V(P5)
>
>【答案】C B B
>
>【解析】方式一：一个进程的开始处，都是 P 操作，进程的结束处，都是 V 操作（第一个进程，是 V 操作）。根据此特点，c 和 f 都是 P 操作，a、b、d 和 e 都是 V 操作。方式二：结合前驱图以及题目中的条件，填写信号量如下图，然后得出各处应填写的操作。
>
><img src="./system-architect-sprint/image-20240323221249198.png" alt="image-20240323221249198" style="zoom:50%;" />
>
>
>
>进程 P1、P2、P3、P4、P5 和 P6 的前趋图如下所示：
>
><img src="./system-architect-sprint/image-20240323221522487.png" alt="image-20240323221522487" style="zoom:50%;" />
>
>若用 PV 操作控制这 6 个进程的同步与互斥的程序如下，那么程序中的空 ① 和空 ② 处应分别为（）；空 ③ 和空 ④ 处应分别为（）；空 ⑤ 和空 ⑥ 处应分别（）。
>
><img src="./system-architect-sprint/image-20240323221604475.png" alt="image-20240323221604475" style="zoom:50%;" />
>
>A. V(S1) V(S2) 和 P(S2)					B. P(S1) P(S2) 和 V(S2)					C. V(S1) V(S2) 和 P(S1)					D. P(S1) P(S2) 和 V(S1)
>
>A. V(S3) 和 V(S5) V(S6)					B. P(S3) 和 V(S5) V(S6)					C. V(S3) 和 P(S5) P(S6)					D. P(S3) 和 P(S5) P(S6)
>
>A. P(S6) 和 P(S7) V(S8)					B. V(S6) 和 V(S7) V(S8)					C. P(S6) 和 P(S7) P(S8)					D. V(S7) 和 P(S7) P(S8)
>
>【答案】C B D
>
>【解析】结合前驱图以及题目中的条件，填写信号量如下图，然后得出各处应填写的操作。
>
><img src="./system-architect-sprint/image-20240324000836620.png" alt="image-20240324000836620" style="zoom:50%;" />
>
>
>
>
>
>

#### 生产者和消费者

经典问题：生产者和消费者的问题

三个信号量：互斥信号量 S0（仓库独立使用权），同步信号量 S1（仓库空闲位置），同步信号量 S2（仓库商品个数）。

<img src="./system-architect-sprint/image-20240321222636612.png" alt="image-20240321222636612" style="zoom: 50%;" />

#### 死锁

当一个进程在等待永远不可能发生的事件时，就会产生死锁，若系统中有多个进程处于死锁状态，就会造成系统死锁。

死锁产生的四个必要条件：

- **资源互斥。**
- **每个进程占有资源并等待其他资源。**
- **系统不能剥夺进程资源。**
- **进程资源图是一个环路。**

死锁产生后，解决措施是打破四大条件，有下列方法：

- `死锁预防`：采用某种策略限制并发进程对于资源的请求，破坏死锁产生的四个条件之一，使系统任何时刻都不满足死锁的条件。
- `死锁避免`： 一般采用**银行家算法**来避免，银行家算法，就是提前计算出一条不会死锁的资源分配方法，才分配资源，否则不分配资源，相当于借贷，考虑对方还得起才借钱，提前考虑好以后，就可以避免死锁。
- `死锁检测`：允许死锁产生，但系统定时运行一个检测死锁的程序，若检测到系统中发生死锁，则设法加以解除。
- `死锁解除`：即死锁发生后的解除方法，如强制剥夺资源，撤销进程等。

死锁计算问题：系统内有 n 个进程，每个进程都需要 R 个资源，那么其**发生死锁的最大资源数为 n * (R - 1)**，其**不发生死锁的最小资源数为 n * (R - 1) + 1**。

>某系统中有 3 个并发进程竞争资源 R，每个进程都需要 5 个 R，那么至少有（）。
>
>A. 12										B. 13										C. 14										D. 15
>
>【答案】B
>
>
>
>银行家算法真题：假设系统中有三类互斥资源 R1、R2 和 R3，可用资源数分别为 10、5 和 3。在 T0 时刻系统中有 P1、P2、P3、P4 和 P5 五个进程，这些进程对资源的最大需求和已分配资源数如下表所示，此时系统剩余的可用资源数分别为（）。如果进程按（）序列执行，那么系统状态是安全的。
>
>A. 1、1 和 0								B. 1、1 和 1								C. 2、1 和 0								D. 2、0 和 1
>
>A. P1一P2一P4一P5一P3 
>
>B. P5一P2一P4一P3一P1
>
>C. P4一P2一P1一P5一P3 
>
>D. P5一P1一P4一P2一P3
>
>【答案】

#### 线程



### 存储管理

#### 页式存储

`页式存储`是操作系统的一种存储管理方式。因为我们的程序往往是远远大于内存的，所以程序在执行的时候，是不会一次性把所有内容都装入到内存中，它会把程序分为若干个**页**，每个页固定大小，一般是 4 KB（默认），然后把这些页离散存入到内存中，而内存是按**块**来划分的，所以就通过**页表**来进行映射程序中的页在内存中的块的存储。

![image-20240322223803342](./system-architect-sprint/image-20240322223803342.png)

- 每个页分为页号和页内地址，页号用来和块号对应，代表存储的位置，大小可以代表页的数量，页内地址代表的是存储的数据内容，大小可以代表数据大小。
- `逻辑地址`是程序员在编写程序时使用的地址，它是由 CPU 生成的虚拟地址，逻辑地址并不一定对应物理内存中的实际位置，而是由操作系统进行地址转换后才能访问物理内存。**逻辑地址的构成是：逻辑页号 + 页内地址。**
- `物理地址`是内存单元在物理内存中的实际位置。它是计算机硬件可以直接寻址的地址。**物理地址的构成是：物理块号 + 页内地址。**

优点：**利用率高、碎片小（只在最后一个页中有）、分配及管理简单。**

缺点：**增加了系统开销，可能产生抖动现象。**

>某计算机系统页面大小为 4 KB，若进程的页面变换表如下所示，逻辑地址为十六进制 1D16H。该地址经过变换后，其物理地址应为十六进制（）。
>
><img src="./system-architect-sprint/image-20240322224103266.png" alt="image-20240322224103266" style="zoom: 40%;" />
>
>A. 1024H										B. 3D16H										C. 4DI6H										D. 6D16H
>
>【答案】B
>
>【解析】**十六进制数字：通常用数字 0、1、2、3、4、5、6、7、8、9 和字母 A、B、C、D、E、F（a、b、c、d、e、f）表示，其中 A ~ F 表示 10 ~ 15。**因为计算机系统页面大小为 4 KB，即页内地址是二进制的 12 位（4 KB = 2^12^），而二进制的 12 位，对应十六进制的 3 位，所以逻辑地址为 1D16H 的十六进制，其后三位 D16 为页内地址，首位 1 为页号。由页表对应关系，页号 1 对应块号 3，所以物理地址为 3D16H。
>
>
>
>某虚拟存储器的用户编程空间共 64 个页面，每页为 1 KB，内存为 16 KB。假定某时刻一用户页表中已调入内存的页面的页号和物理块号的对照表如下，则逻辑地址 0A5CH 所对应的物理地址是什么？要求：写出主要计算过程。 
>
>| 页号 | 块号 |
>| ---- | ---- |
>| 0    | 3    |
>| 1    | 7    |
>| 2    | 9    |
>| 3    | 5    |
>
>【解析】**由 "用户编程空间共 64 个页面"，64 = 2^6^，可知页号部分占 6 位；由 "每页为 1 KB"，1 KB = 2^10^，可知页内地址占 10 位；由 "内存为 16 KB"，16 = 2^4^，可知块号占 4 位。**逻辑地址 0A5CH，所对应的二进制表示形式是：0000 1010 0101 1100，后十位 10 0101 1100 是页内地址，前六位 0000 10 为页号，页号转换为十进制是 2。由页表对应关系，页号 2 对应块号 9，9 转换为二进制是 1001，因此，可以求出物理地址为：1001 10 0101 1100，转换成十六进制为 265CH。即逻辑地址 0A5CH 所对应的物理地址是 265CH。

#### 页面置换算法

有时候，进程空间分为 100 个页面，而系统内存只有 10 个物理块，无法全部满足分配，就需要将马上要执行的页面先分配进去，而后根据算法进行淘汰，使 100 个页面能够按执行顺序调入物理块中执行完。

`缺页`表示需要执行的页不在内存物理块中，需要从外部调入内存，会增加执行时间，因此，缺页数越多，系统效率越低。

页面置换算法：

- `最优算法`：OPT，**理论上的算法**，无法实现，是在进程执行完后进行的最佳效率计算，用来让其他算法比较差距。原理是选择未来最长时间内不被访问的页面置换，这样可以保证未来执行的都是马上要访问的。
- `先进先出算法`：FIFO，先调入内存的页先被置换淘汰，**会产生抖动现象**，即分配的页数越多，缺页率可能越多，**效率越低**。
- `最近最少使用`：LRU，在最近的过去，进程执行过程中，过去最少使用的页面被置换淘汰，根据局部性原理，这种方式**效率高**，且**不会产生抖动现象**。

>某进程有 4 个页面，页号为 0 ~ 3，页面变换表及状态位、访问位和修改位的含义如下图所示，若系统给该进程分配了 3 个存储块，当访问前页面 1 不在内存时，淘汰表中页号为（）的页面代价最小。
>
><img src="./system-architect-sprint/image-20240323095208290.png" alt="image-20240323095208290" style="zoom:50%;" />
>
>A. 0													B. 1													C. 2													D. 3
>
>【答案】D

#### 快表

`快表`是一块小容量的相联存储器，由快速存储器组成，按内容访问，速度快，并且可以从硬件上保证按内容并行查找，一般用来存放当前访问最频繁的少数活动页面的页号（可以看成是页表的频繁访问数据的副本）。

<img src="./system-architect-sprint/image-20240323100039085.png" alt="image-20240323100039085" style="zoom:50%;" />

- **快表是将页表存于 Cache 中。**

- **慢表是将页表存于内存中。**
- 因此，慢表需要访问两次内存才能取出数据，而快表是访问一次 Cache 和一次内存，因此更快。

#### 段式存储

`段式存储`将进程空间分为一个个段，每段也有段号和段内地址，与页式存储不同的是，**每段物理大小不同**，分段是根据逻辑整体分段的。

`地址表示：(段号，段内偏移)`。其中段内偏移不能超过该段号对应的段长，否则越界错误，而此地址对应的真正内存地址应该是：**段号对应的基地址 + 段内偏移**。

<img src="./system-architect-sprint/image-20240323101130425.png" alt="image-20240323101130425" style="zoom:67%;" />

优点：**程序逻辑完整，修改互不影响。**

缺点：**内存碎片浪费大，导致内存利用率低。**

>设某进程的段表如下所示，逻辑地址（）可以转换为对应的物理位置。
>
><img src="./system-architect-sprint/image-20240323101331399.png" alt="image-20240323101331399" style="zoom:50%;" />
>
>A. (0，1597)、(1，30) 和 (3，1390)
>
>B. (0，128)、(1，30) 和 (3，1390)
>
>C. (0，1597)、(2，98) 和 (3，1390)
>
>D. (0，128)、(2，98) 和 (4，1066)
>
>【答案】B
>
>【解析】0 号段，段内偏移为 600；1 号段，段内偏移为 50；2 号段，段内偏移为 100；3 号段，段内偏移为 2988；4 号段，段内偏移为 960。

#### 段页存储

`段页存储`对进程空间先分段，后分页。

<img src="./system-architect-sprint/image-20240323101801546.png" alt="image-20240323101801546" style="zoom: 50%;" />

优点：空间浪费小、存储共享容易、能动态连接。

缺点：由于管理软件的增加，复杂性和开销也增加，执行速度下降。

### 文件管理

#### 文件结构

计算机系统中采用的索引文件结构如下图所示：

<img src="./system-architect-sprint/image-20240323102155961.png" alt="image-20240323102155961" style="zoom:50%;" />

- 系统中有 13 个索引节点，0 ~ 9 为`直接索引`，即每个索引节点存放的是内容，假设每个物理盘大小为 4 KB，共可存 4 KB * 10 = 40 KB 数据。

- 10 号为`一级间接索引`节点，大小为 4 KB，存放的并非直接数据，而是链接到直接物理盘块的地址，假设每个地址占 4 B，则共有 1024 个地址，对应 1024 个物理盘，可存 1024 * 4 KB * 1 = 4098 KB 数据。
- 11 号为`二级间接索引`节点，直接盘存放一级地址，一级地址再存放物理盘快地址，而后链接到存放数据的物理盘块，容量又扩大了一个数量级，为 1024 *1024 * 4 KB * 1 = 4194304 KB 数据。
- 三级简介索引类推。

>设文件索引节点中有 8 个地址项，每个地址项大小为 4 字节，其中 5 个地址项为直接地址索引，2 个地址项是一级间接地址索引，1 个地址项是二级间接地址索引，磁盘索引块和磁盘数据块大小均为 1 KB，若要访问文件的逻辑块号分别为 5 和 518，则系统应分别采用（），而且可表示的单个文件最大长度是（）KB。
>
>A. 直接地址索引和一级间接地址索引
>
>B. 直接地址索引和二级间接地址索引
>
>C. 一级间接地址索引和二级间接地址索引
>
>D. 一级间接地址索引和一级间接地址索引
>
>A. 517										B. 1029										C. 16513										D. 66053
>
>【答案】C D
>
>【解析】磁盘索引块大小为 1 KB，每个地址项大小为 4 B，则每个磁盘索引块存放 1 KB / 4 B = 256 个地址项。直接索引 5 个，存放 0 ~ 4 号逻辑块；一级间接索引 2 个，存放 5 ~ 517 号逻辑块；518 及其之后的逻辑块，存放在二级间接索引。可表示的单个文件最大长度为：256 * 256 * 1 * 1 KB + 256 * 2 * 1 KB + 5 * 1 KB = 66053 KB。

#### 树形文件

`相对路径`：是从当前路径开始的路径。

`绝对路径`：是从根目录开始的路径。

`全文件名`：绝对路径 + 文件名。

注意，绝对路径和相对路径是不加最后的文件名的，只是单纯的路径序列。树形结构主要是区分相对路径和绝对路径，如下图所示：

<img src="./system-architect-sprint/image-20240323142039387.png" alt="image-20240323142039387" style="zoom:50%;" />

文件属性：

- R：只读文件属性。
- A：存档属性。
- S：系统文件。
- H：隐藏文件。

文件名的组成：

- 驱动器号
- 路径
- 主文件名
- 扩展名

>若某文件系统的目录结构如下图所示，假设用户要访问文件 Fault.swf，且当前工作目录为 swshare，则该文件的全文件名为（），相对路径和绝对路径分别为（）。
>
><img src="./system-architect-sprint/image-20240323142335215.png" alt="image-20240323142335215" style="zoom: 50%;" />
>
>A. Fault.swf					B. flash\Fault.swf					C. swshare\flash\Fault.swf					D. \swshare\flash\Fault.swf
>
>A. swshare\flash\和\flash\			B. flash和\swshare\flash\			C. \swshare\flash\和flash\			D. \flash\和\swshare\flash\
>
>【答案】D B

#### 空间存储

空闲区表法：将所有空闲空间整合成一张表，即空闲文件目录。

空闲链表法：将所有空闲空间链接成一个链表，根据需要分配。

成组链接法：既分组，每组内又链接成链表，是上述两种方法的综合。

`位示图法`：**对每个物理空间用一位标识，为 1 则使用，为 0 则空闲，形成一张位示图。**

<img src="./system-architect-sprint/image-20240323142912081.png" alt="image-20240323142912081" style="zoom:50%;" />

>某文件管理系统在磁盘上建立了位示图（bitmap），记录磁盘的使用情况。若磁盘上的物理块依次编号为：0、1、2、…，系统中字长为 32 位，每一位对应文件存储器上的一个物理块，取值 0 和 1 分别表示空闲和占用，如下图所示。
>
><img src="./system-architect-sprint/image-20240323143006894.png" alt="image-20240323143006894" style="zoom:50%;" />
>
>假设将 4195 号物理块分配给某文件，那么该物理块的使用情况在位示图中的第（）个字中描述，系统应该将（）。
>
>A. 129										B. 130										C. 131										D. 132
>
>A. 该字的第 3 个位置为 "0"
>
>B. 该字的第 3 个位置为 "1"
>
>C. 该字的第 4 个位置为 "0"
>
>D. 该字的第 4 个位置为 "1"
>
>【答案】D D
>
>【解析】系统中字长为 32 位，可以存放 0 ~ 31 号物理块，即 32 个物理块。4195 号物理块，是第 4196 个，4196 除以 32，得 131 余 4，即在该位示图得第 132 个字中描述，且该字的 第 4 个位置（3 号位）标识为 1。

### 设备管理

#### 虚设备和 SPOOLING 技术

一台实际的物理设备，例如打印机，在同一时间只能由一个进程使用，其他进程只能等待，且不知道什么时候打印机空闲，此时，极大的浪费了外设的工作效率。

引入`SPOOLING 技术`，就是在外设上建立两个数据缓冲区，分别称为**输入井和输出井**，这样，无论多少进程，都可以共用这一台打印机，只需要将打印命令发出，数据就会排队存储在缓冲区中，打印机会自动按顺序打印，实现了物理外设的共享，使得每个进程都感觉在使用一个打印机，这就是`物理设备的虚拟化`。如下图所示：

<img src="./system-architect-sprint/image-20240323190401076.png" alt="image-20240323190401076" style="zoom:50%;" />



## 本文参考

https://www.zhihu.com/education/training/course-detail/1748737088365821953（请支持正版）

## 声明

写作本文初衷是个人学习记录，鉴于本人学识有限，如有侵权或不当之处，请联系 [wdshfut@163.com](mailto:wdshfut@163.com)。
