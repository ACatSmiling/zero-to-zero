## 计算机基础

### 计算机硬件组成、CPU 和校验码

#### 计算机硬件组成

计算机硬件组成：

- 计算机的基本硬件系统由`运算器`、`控制器`、`存储器`、`输入设备`和`输出设备` 5 大部件组成。
- 运算器、控制器等部件被集成在一起统称为中央处理单元（Central Processing Unit，CPU）。CPU 是硬件系统的核心，用于数据的加工处理，能完成各种算术、逻辑运算及控制功能。
- 存储器是计算机系统中的记忆设备，分为内部存储器和外部存储器。前者速度高、容量小，一般用于临时存放程序、数据及中间结果。而后者容量大、速度慢，可以长期保存程序和数据。
- 输入设备和输出设备合称为外部设备（简称外设），输入设备用于输入原始数据及各种命令，而输出设备则用于输出计算机运行的结果。

#### CPU

CPU 的功能：

- `程序控制`：CPU 通过执行指令来控制程序的执行顺序，这是 CPU 的重要功能。
- `操作控制`：一条指令功能的实现需要若干操作信号配合来完成，CPU 产生每条指令的操作信号并将操作信号送往对应的部件，控制相应的部件按指令的功能要求进行操作。
- `时间控制`：CPU 对各种操作进行时间上的控制，即指令执行过程中操作信号的出现时间、持续时间及出现的时间顺序都需要进行严格控制。
- `数据处理`：CPU 通过对数据进行算术运算及逻辑运算等方式进行加工处理，数据加工处理的结果被人们所利用。所以，**对数据的加工处理也是 CPU 最根本的任务。**
- 此外，CPU 还需要对系统内部和外部的中断或异常做出响应，进行相应的处理。

CPU 的组成：CPU 主要由`运算器`、`控制器`、`寄存器组`和`内部总线`等部件组成。

- **运算器**：执行所有的算术运算，如加减乘除等；执行所有的逻辑运算并进行逻辑测试，如与、或、非、比较等。
  - `算术逻辑单元 ALU`：实现对数据的算术和逻辑运算。
  - `累加寄存器 AC`：运算结果或源操作数的存放区。
  - `数据缓冲寄存器 DR`：暂时存放内存的指令或数据。
  - `状态条件寄存器 PSW`：保存指令运行结果的条件码内容，如溢出标志等。
- **控制器**：控制整个 CPU 的工作，最为重要。
  - `指令寄存器 IR`：暂存 CPU 执行指令。
  - `程序计数器 PC`：存放指令执行地址。
  - `地址寄存器 AR`：保存当前 CPU 所访问的内存地址。
  - `指令译码器 ID`：分析指令操作码。
- CPU 依据指令周期的不同阶段来区分二进制的指令和数据，因为在指令周期的不同阶段，指令会命令 CPU 分别去取指令或者数据。

> 考试真题：
>
> CPU 执行算术运算或者逻辑运算时，常将源操作数和结果暂存在（）中。
>
> A. 程序计数器（PC） 
>
> B. 累加器（AC）
>
> C. 指令寄存器（IR） 
>
> D. 地址寄存器（AR）
>
> 【答案】B
>
> 
>
> 执行CPU指令时，在一个指令周期的过程中，首先需从内存读取要执行的指令，此时先要将指令的地址即（）的内容送到地址总线上。
>
> A. 指令寄存器（IR） 
>
> B. 通用寄存器（GR） 
>
> C. 程序计数器（PC）
>
> D. 状态寄存器（PSW）
>
> 【答案】C

#### 校验码

为什么要用校验码：为了应对`突发错误 (BurstError)`，即两个或更多个数据位在码流中出现的错误。

为什么会出现这些数据位错误：对于电子系统通信，它涉及到物理层、链路层、通信介质等，其中物理层主要将原始二进制数据利用一定的编解码原理对其进行调制，然后经由发送电路将调制信号输送至传输介质，接收端利用接收电路进行接收并解调，将信息还原成二进制码流。在这个过程中介质有可能被干扰，接收电路、发送电路、调制电路、解调电路都可能由于某些干扰原因导致工作失效而出现误码。此时，如果没有一个很好的机制去确保数据的正确性，比如一个飞控系统中某些控制命令、车辆系统中 CAN 报文数据，系统直接使用这些错误数据去控制被控对象（比如电机、发动机等），严重的时候就会造成难以估量的生命财产灾难。所以，**对于数据完整性检测的重要性不言而喻**。

`码距`：就单个编码 "A: 00" 而言，其码距为 1，因为其只需要改变一位就变成另一个编码。**在两个编码中，从 A 码到 B 码转换所需要改变的位数称为码距。**如 "A: 00" 要转换为 "B: 11"，码距为 2。一般来说，码距越大，越利于纠错和检错。

##### 奇偶校验码

特点：

- 无论数据位多少位，校验位只有一位。
- 数据位和校验位一共所含的 1 个数为奇数，称为`奇校验`。
- 数据位和校验位一共所含的 1 个数为偶数，称为`偶校验`。

示例：

<img src="system-architect/image-20240121114738396.png" alt="image-20240121114738396" style="zoom:50%;" />

- 第一条原始码有三个 1，对于奇校验，最后一位补 0，对于偶校验，最后一位补 1。
- 第二条原始码有两个 1，对于奇校验，最后一位补 1，对于偶校验，最后一位补 0。
- 其他以此类推。

奇偶校验码错误检测能力：**只能检测出奇数个错误。**

<img src="system-architect/image-20240121145849437.png" alt="image-20240121145849437" style="zoom:50%;" />

那么使用中是选择奇校验还是偶校验呢？其实都有应用了。

> *奇校验一个重要的特征是产生不了全 0 代码，所以在实际操作过程中选择的时候要考虑到这一点。*

##### CRC 校验码

**CRC 校验码只能检错，不能纠错。**

使用 CRC 校验码，需要先约定一个生成多项式 $G(x)$，生成多项式的最高位和最低位必须是 1。假设原始信息有 $m$ 位，则对应多项式 $M(x)$。**生成校验码思想就是在原始信息位后追加若干校验位，使得追加的信息能被 $G(x)$ 整除。接收方接收到带校验位的信息，然后用 $G(x)$ 整除。余数为 0，则没有错误；反之则发生错误。**

计算过程：假设原始信息串为 10110，CRC 的生成多项式为 $G(x)=x^4+x+1$，求 CRC 校验码。

（1）在原始信息位后面添 0，假设生成多项式的阶为 $r$，则在原始信息位后添加 $r$ 个 0，本题中，$G(x)$ 阶为 4，则在原始信息串后加 4 个 0，得到的新串为 101100000，作为被除数。

（2）由多项式得到除数，多项中 $x$ 的幂指数存在的位置 1，不存在的位置 0。本题中，$x$ 的幂指数为 0，1，4 的变量都存在，而幂指数为 2，3 的不存在，因此得到串 10011。

（3）生成 CRC 校验码，将前两步得出的被除数和除数进行模 2 除法运算（即不进位也不借位的除法运算）。除法过程如下图所示，得到余数 1111。

<img src="system-architect/image-20240121150647064.png" alt="image-20240121150647064" style="zoom:50%;" />

- 注意：**如果余数不足 $r$，则在余数左边用若干个 0 补齐。**如求得余数为 11，$r$ 等于 4，则补两个 0 得到 0011。

（4）生成最终发送信息串，将余数添加到原始信息后。本题中，原始信息为 10110，添加余数 1111 后，结果为 101101111，发送方将此数据发送给接收方。

（5）接收方进行校验。接收方的 CRC 校验过程与生成过程类似，接收方接收了带校验和的帧后，用多项式 $G(x)$ 来除。余数为 0，则表示信息无错；否则要求发送方进行重传。

- 注意：收发信息双方需使用相同的生成多项式。	

> 考试真题：
>
> 循环冗余校验码（Cyclic Redundancy Check，CRC）是数据通信领域中最常用的一种差错校验码，该校验方法中，使用多项式除法（模 2 除法）运算后的余数为校验字段。若数据信息为 $n$ 位，则将其左移 $k$ 位后，被长度为 $k+1$ 位的生成多项式相除，所得的 $k$ 位余数即构成 $k$ 个校验位，构成 $n+k$ 位编码。若数据信息为 1100，生成多项式为 $x^3+x+1$（即 1011），则 CRC 编码是（）。
>
> A. 1100010
>
> B. 1011010
>
> C. 1100011
>
> D. 1011110
>
> 【解析】
>
> CRC 循环校验码的编码流程为：
>
> 1. 在原始信息位后加 $k$ 个 0，即 1100000。
> 2. 将 1100000 与生成多项式 1011 做模 2 除法，得到余数为 010。
> 3. 将原始信息位与余数连接起来得到 1100010。
>
> 【答案】A

### 指令系统、存储系统和缓存

#### 指令系统

计算机指令的组成：一条指令由`操作码`和`操作数`两部分组成， 操作码决定要完成的操作，操作数指参加运算的数据及其所在的单元地址。

在计算机中， 操作要求和操作数地址都由二进制数码表示，分别称作`操作码`和`地址码`，整条指令以二进制编码的形式存放在存储器中。

<img src="system-architect/image-20240121213938223.png" alt="image-20240121213938223" style="zoom:50%;" />

计算机指令执行过程： `取指令 ——> 分析指令 ——> 执行指令`三个步骤。

-  首先，将程序计数器 PC 中的指令地址取出，送入地址总线，CPU 依据指令地址去内存中取出指令内容存入指令寄存器 IR。
- 然后，由指令译码器进行分析，分析指令操作码。
- 最后，执行指令，取出指令执行所需的源操作数。

**指令寻址方式**，即怎么找到下一条指令：

1. `顺序寻址方式`： 当执行一段程序时，根据 PC（程序计数器） 中指令，是一条指令接着一条指令地顺序执行 。
2. `跳跃寻址方式`： 指下一条指令的地址码不是由程序计数器给出，而是由本条指令直接给出。程序跳跃后，按新的指令地址开始顺序执行。因此， 程序计数器的内容也必须相应改变，以便及时跟踪新的指令地址。

**指令操作数的寻址方式**，即怎么找到操作数：

- `立即寻址方式`：指令的地址码字段指出的不是地址， 而是操作数本身。
- `直接寻址方式`：在指令的地址字段中直接指出操作数在主存中的地址。
- `间接寻址方式`：指令地址码字段所指向的存储单元中存储的是操作数的地址。 
- `寄存器寻址方式`：指令中的地址码是寄存器的编号。
- `基址寻址方式`：将基址寄存器的内容加上指令中的形式地址而形成操作数的有效地址，其优点是可以扩大寻址能力。
- `变址寻址方式`：变址寻址方式计算有效地址的方法与基址寻址方式很相似，它是将变址寄存器的内容加上指令中的形式地址而形成操作数的有效地址。

**指令系统的分类：**

- `CISC`：是复杂指令系统，兼容性强，指令繁多、长度可变，由微程序实现。

- `RISC`：是精简指令系统，指令少，使用频率接近，主要依靠硬件实现（通用寄存器 、硬布线逻辑控制）。

- 二者具体区别如下：

  <img src="system-architect/image-20240121215329158.png" alt="image-20240121215329158" style="zoom: 50%;" />

> 考试真题：
>
> Flynn 分类法根据计算机在执行程序的过程中（）的不同组合，将计算机分为 4 类。当前主流的多核计算机属于（）计算机。
>
> A. 指令流和数据流
>
> B. 数据流和控制流
>
> C. 指令流和控制流
>
> D. 数据流和总线带宽
>
> A. SISD
>
> B. SIMD
>
> C. MISD
>
> D. MIMD
>
> 【解析】
>
> <img src="system-architect/image-20240121215828095.png" alt="image-20240121215828095" style="zoom: 80%;" />
>
> 【答案】A D
>
> 
>
> 以下关于复杂指令集计算机（Complex Instruction Set Computer，CISC） 的叙述中， 正确的是（）。
>
> A. 只设置使用频度高的一些简单指令，不同指令执行时间差别很小。
>
> B. CPU 中设置大量寄存器，利用率低。
>
> C. 常采用执行速度更快的组合逻辑实现控制器。
>
> D. 指令长度不固定，指令格式和寻址方式多变。
>
> 【答案】D

`指令流水线原理`：将指令分成不同段，每段由不同的部分去处理，因此可以产生叠加的效果，所有的部件去处理指令的不同段。

<img src="system-architect/image-20240121220545598.png" alt="image-20240121220545598" style="zoom: 67%;" />

- 对于左图，1，2，3 三条任务，是串行执行每一个指令。
- 对于右图，取指，分析和执行，是并行的。

> *指令流水线，只在 RISC 中才有。*

**RISC 中的流水线技术：**

1. `超流水线 (Super Pipe Line) 技术`：它通过细化流水、增加级数和提高主频，使得在每个机器周期内能完成一个甚至两个浮点操作，**其实质是以时间换取空间**。
2. `超标量 (Super Scalar) 技术`：它通过内装多条流水线来同时执行多个处理，其时钟频率虽然与一般流水接近，却有更小的 CPI，**其实质是以空间换取时间**。
3. `超长指令字 (Very Long InstructionWord，VLIW) 技术`： VLIW 和超标量都是 20 世纪 80 年代出现的概念，其共同点是要同时执行多条指令，其不同在于超标量依靠硬件来实现并行处理的调度，VLIW 则充分发挥软件的作用而使硬件简化，性能提高。

**流水线时间计算：**

1. `流水线周期`：指令分成不同执行段，其中执行时间最长的段为流水线周期。
2. `流水线执行时间`：**`1条指令总执行时间+(总指令条数-1)＊流水线周期`**。
3. `流水线吞吐率计算`：吞吐率即单位时间内执行的指令条数。计算公式：**`指令条数／流水线执行时间`**。
4. `流水线的加速比计算`：加速比即使用流水线后的效率提升度，即比不使用流水线快了多少倍，越高表明流水线效率越高。计算公式：**`不使用流水线执行时间／使用流水线执行时间`**。

> 考试真题：
>
> 流水线的吞吐率是指流水线在单位时间里所完成的任务数或输出的结果数。设某流水线有 5 段，有 1 段的时间为 2 ns，另外 4 段的每段时间为 1 ns，利用此流水线完成 100 个任务的吞吐率约为（）个／s。
>
> A. $500*10^6$
>
> B. $490*10^6$
>
> C. $250*10^6$
>
> D. $167*10^6$
>
> 【解析】
>
> 流水线执行 100 个任务需要时间：$(2+1+1+1+1)+(100-1)*2=204ns$
>
> 吞吐率：$(100/204)*10^9=490*10^6$
>
> 注意：$1s=10^9ns$。
>
> 【答案】B
>
> 
>
> 假设磁盘块与缓冲区大小相同，每个盘块读入缓冲区的时间为 15 us，由缓冲区送至用户区的时间是 5 us，在用户区内系统对每块数据的处理时间为 1 us，若用户需要将大小为 10 个磁盘块的 Docl 文件逐块从磁盘读入缓冲区，并送至用户区进行处理，那么采用单缓冲区需要花费的时间为（）us；采用双缓冲区需要花费的时间为（）us。
>
> A. 150
>
> B. 151
>
> C. 156
>
> D. 201
>
> A. 150
>
> B. 151
>
> C. 156
>
> D. 201
>
> 【解析】
>
> `单缓冲区`：前两段合并，两端流水线，$20+1+20*(10-1)=201$。
>
> - 单缓冲区：盘块读入缓冲区的操作，与缓冲区送至用户区的操作是串行，这两段合并，流水线周期为 20 us。
>
> `双缓冲区`：标准三段流水线，$15+5+1+15*(10-1)=156$。
>
> - 双缓冲区：盘块读入缓冲区的操作，与缓冲区送至用户区的操作是并行，这两段不需要合并，流水线周期为 15 us。
>
> 【答案】D C
>
> 
>
> 流水线技术是通过并行硬件来提高系统性能的常用方法。对于一个 $k$ 段流水线，假设其各段的执行时间均相等（设为 $t$），输入到流水线中的任务是连续的理想情况下，完成 $n$ 个连续任务需要的总时间为（）。若某流水线浮点加法运算器分为 5 段，所需要的时间分别是 6 ns、7 ns、8 ns、9 ns 和 6 ns，则其最大加速比为（）。
>
> A. $nkt$
>
> B. $(k+n-1)t$
>
> C. $(n-k)kt$
>
> D. $(k+n+1)t$
>
> A. 4
>
> B. 5
>
> C. 6
>
> D. 7
>
> 【解析】
>
> 当流水线各段执行时间相等时，公式化简后，完成 $n$ 个连续任务需要的总时间为 $(k+n-1)*t$。
>
> 加速比定义为顺序执行时间与流水线执行时间的比值，根据题干假设，假设一共有 $n$ 条指令，则顺序执行时间为 $(6+7+8+9+6)*n=36n$，该流水线周期为最长的 9 ns，则在流水线中执行的时间为 $36+9*(n-1)=9n+27$，因此加速必为 $36n/(9n+27)$，题目问最大加速比，由这个公式可以知道，当 $n$ 越大时，该公式值越大，因此最大的时间就是 $n$ 趋向于无穷大，此时可以忽略分母 27，也就是 $36n/9n=4$。
>
> 【答案】B A

#### 存储系统和缓存

计算机采用`分级存储体系`，其主要目的是为了**解决存储容量、成本和速度之间的矛盾问题**。

<img src="system-architect/image-20240121230715795.png" alt="image-20240121230715795" style="zoom: 50%;" />

`两级存储`： Cache - 主存、主存 - 辅存（虚拟存储体系）。

对于缓存的处理逻辑，操作系统整体上遵循`局部性原理`，总的来说，在 CPU 运行时，所访问的数据会趋向于一个较小的局部空间地址内，包括下面两个方面：

- `时间局部性原理`：如果一个数据项正在被访问，那么在近期它很可能会被再次访问，即**在相邻的时间里会访问同一个数据项**。
- `空间局部性原理`：在最近的将来会用到的数据的地址和现在正在访问的数据地址很可能是相近的，即**相邻的空间地址会被连续访问**。

`高速缓存 Cache`：用来存储当前最活跃的程序和数据，直接与 CPU 交互，位于 CPU 和主存之间，容量小，速度为内存的 5 ~ 10 倍，由半导体材料构成。其内容是主存内存的副本拷贝，对于程序员来说是透明的。

`Cache 由控制部分和存储器组成`：存储器存储数据，控制部分判断 CPU 要访问的数据是否在 Cache 中，在则命中，不在则依据一定的算法从主存中替换。

`地址映射`： 在 CPU 工作时，送出的是主存单元的地址，而应从 Cache 存储器中读／写信息，这就需要将主存地址转换为 Cache 存储器地址，这种地址的转换称为地址映射，**由硬件自动完成映射**。分为下列三种方法：

- `直接映射`：将 Cache 存储器等分成块，主存也等分成块并编号。主存中的块与 Cache 中的块的对应关系是固定的，也即二者块号相同才能命中。地址变换简单但不灵活，容易造成资源浪费。如图所示：
- `全相联映射`：同样都等分成块并编号。主存中任意一块都与 Cache 中任意一块对应。因此可以随意调入 Cache 任意位置，但地址变换复杂，速度较慢。因为主存可以随意调入 Cache 任意块，只有当 Cache 满了才会发生块冲突，是最不容易发生块冲突的映像方式。
- `组组相连映射`：前面两种方式的结合，将 Cache 存储器先分块再分组，主存也同样先分块再分组，组间采用直接映像，即主存中组号与 Cache 中组号相同的组才能命中，但是组内全相联映像，也即组号相同的两个组内的所有块可以任意调换。